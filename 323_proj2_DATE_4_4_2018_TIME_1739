#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>
using namespace std;

//struct for holding LA record
struct LA_output{
    string token;   //category
    string lexeme;  //actual
};

//functions to write to file
template <typename T>
void writetofile(ofstream& ofs, T& x, string token, LA_output & val) {
    val.lexeme = x;
    val.token = token;
    ofs << setw(10) << x << "\t\t\t" << token << endl;
}
template <typename T>
void writetofile(T* x, string token, LA_output & val) {
    val.lexeme = x;
    val.token = token;
    writetofile(*x, token);
}

void SA_output(ofstream & ofs, string production){
    ofs << production;
}
///////////////////////////////////////////////////////////////////////////////////
void m_id_key(ofstream& ofs, char *&p, string * keyword, LA_output & val) {
    //since starting state is 1 and entering this function requires a letter input
    int state = 2;
    bool found_keyword = false;
    string word = "";
    /*
     A finite state machine for identifiers and keywords;
     will continue checking character inputs as long as
     they are valid inputs (letter, digit, $).
     Accepting states 2, 3, 5
     */
    int id_FSM[6][4]{
        //state   L   D   $
        1,        2,  6,  6,
        2,        3,  4,  5,
        3,        3,  4,  5,
        4,        3,  4,  5,
        5,        6,  6,  6,
        6,        6,  6,  6
        
    };
    //while valid input
    while (((isalpha(*p)) || (isdigit(*p))) || (*p == '$')) {
        if (isalpha(*p))
            state = id_FSM[state - 1][1];
        else if (isdigit(*p))
            state = id_FSM[state - 1][2];
        else
            state = id_FSM[state - 1][3];
        word += *p;
        ++p;
    }
    //if accepting state
    if (((state == 2) || (state == 3)) || (state == 5)) {
        //check if keyword
        for (int i = 0; i < 13; i++) {
            if (word == keyword[i]) {
                found_keyword = true;
                writetofile(ofs, word, "keyword", val);
            }
        }
        //otherwise its an identifier
        if (!found_keyword)
            writetofile(ofs, word, "identifier", val);
    }
    //not accepting state
    else
        writetofile(ofs, word, "unknown", val);
}
//determines whether the input characters are integers or real numbers
void m_int_real(ofstream& ofs, char*&p, LA_output & val) {
    int state = 2; //set to 2 since input char was a digit
    /*
     combination of integer and real number FSM
     states 2 is accepting states for integer numbers
     state 4 is the accepting state for real numbers
     state 5 is an error state.
     */
    int int_real_FSM[5][3]{
        //state     D   .
        1,          2,  5,
        2,          2,  3,
        3,          4,  5,
        4,          4,  5,
        5,          5,  5,
    };
    string word = "";
    //while valid input
    while (isdigit(*p) || (*p) == '.') {
        if (isdigit(*p))
            state = int_real_FSM[state - 1][1];
        else
            state = int_real_FSM[state - 1][2];
        word += *p;
        ++p;
    }
    if (state == 2)
        writetofile(ofs, word, "integer", val);
    else if (state == 4)
        writetofile(ofs, word, "real", val);
    else
        writetofile(ofs, word, "unknown", val);
}

//determines if the character is a separator
bool is_sep(ofstream& ofs, char *&p, char * sep, LA_output & val) {
    for (int i = 0; i < 10; i++){
        if (*p == sep[i]){
            if (*p == '%'){
                //if next char is also %
                if (*(++p) == '%'){
                    writetofile(ofs, "%%","separator", val);
                    ++p;
                    return true;
                }
                else{
                    //decrement to original p for error message
                    --p;
                    char tmp = p[0];
                    writetofile(ofs, tmp,"unknown", val);
                    ++p;
                    return true;
                }
            }
            else{
                char tmp = p[0];
                writetofile(ofs, tmp,"separator", val);
                ++p;
                return true;
            }
        }
    }
    return false;
}
//determines if the current character and next char are operators
bool is_op(ofstream& ofs, char *&p, char * ope, LA_output & val) {
    string two_char_operator [4] = {"==", "=>", "=<", "^="};
    
    string word_ope = "";
    for (int i = 0; i < 8; i++) {
        if (*p == ope[i]) {
            word_ope += *p;
            ++p;
            //second loop to check if next char is part of operator
            for (int k = 0; k < 8; k++) {
                if (*p == ope[k]) {
                    word_ope += *p;
                    for (int j = 0; j < 4; j++){
                        if (word_ope == two_char_operator[j]){
                            writetofile(ofs, word_ope, "operator", val);
                            //cout << word_ope << " is valid" << endl;
                            ++p;
                            return true;
                        }//end if two_char operator
                    }//end for checking valid two_char operator
                    //if second char isn't a valid operator
                    ++p;
                    writetofile(ofs, word_ope, "unknown", val);
                    //cout << word_ope << " is not valid" << endl;
                    return true;
                }//end if second char is an operator
            }//end for k
            writetofile(ofs, word_ope, "operator", val);
            //cout << word_ope << " is valid" << endl;
            return true;
        }//end if first char is an operator
    }
    //cout << word_ope << " is not valid" << endl;
    return false;
}
//checks for comments
bool is_comment(char *&p, fstream & fin, string & x){
    if (*p == '!'){
        ++p;
        while (*p != '!')
        {
            if (p != &x[x.length()])
                ++p;
            else
            {
                getline(fin, x);
                p = &x[0];
            }
        }
        ++p;
        return true;
    }
    return false;
}

//the lexer function considers all valid inputs
LA_output lexer(char *& p, ofstream & outfile, fstream & fin, string & x){
    //valid keywords, separators, and operators
    string keywords[13] = { "int","boolean","real","function","return","true",
        "false","if","else","endif","while","get","put" };
    char separators[10] = { '(',')',':',',','{','}', ']', '[', ';', '%' };
    char operators[8] = { '<','>','=','^','+','-','*','/' };
    
    LA_output ex;
    if (isalpha(*p))m_id_key(outfile, p, keywords, ex);
    else if (isdigit(*p))m_int_real(outfile, p, ex);
    else if (is_op(outfile, p, operators, ex)) {}
    else if (is_sep(outfile, p, separators, ex)) {}
    else if ((((*p) == 32) || (*p == '\t')) || ((*p == '\n') || (int)(*p) == 13)) {
        ++p;
        //lexer (p, outfile, fin, x);
    }
    else if (is_comment(p, fin, x)){}
    else {
        char tmp = p[0];
        writetofile(outfile, tmp, "unknown", ex);
        ++p;
    }
    return ex;
}

bool is_space(char x){
    if ((((x) == 32) || (x == '\t')) || ((x == '\n') || (int)(x) == 13)) return true;
    return false;
}


/*
 Assume we have the following statement
 a = b + c;
 
 One possible output would be as follows:
 
 Token: Identifier          Lexeme: a
 <Statement> -> <Assign>
 <Assign> ->  <Identifier>  = <Expression> ;
 
 Token: Operator          Lexeme: =
 
 Token: Identifier          Lexeme: b
 <Expression> -> <Term> <Expression Prime>
 <Term> -> <Factor> <Term Prime>
 <Factor> -> <Identifier>
 
 Token:  Operator          Lexeme: +
 <Term Prime> -> ε
 <Expression Prime> -> + <Term> <Expression Prime>
 
 Token:  Identifier           Lexeme: c
 <Term>  -> <Factor> <Term Prime>
 <Factor> -> <Identifier>
 
 Token: Separator           Lexeme: ;
 <Term Prime> -> ε
 <Expression Prime> -> ε
*/

/*
Notes: I think we must call the lexer in a specific function and expect to see a certain
 token value, if not, it changes the direction of our syntax analysis or it could be an error.
 For the example, a = b + c, when we see "a", we limit the various options available for 
 an identifier as the first token. Once we find a rule that expects an identifier as the first token
 in the line, we call the lexer (AT THAT POINT) to see if the next token is an "=".  If so,
 we must continue down the <assign> path which expects an "=" sign next.  We again call the 
 lexer (AT THAT POINT) and satisfy the valid conditions for <expression>.  If we are unable to satisfy
 the conditions for <expression> there is an error.
*/


//r29
void empty(char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    SA_output(outfile, "<Empty>");
}

//r28
void primary(char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    if (record.token == "identifier"){
        SA_output(outfile, "<primary> -> <identifier>\n");
    }
    if (record.token == "integer"){
        SA_output(outfile, "<primary> -> <integer\n");
    }
}

//r27
void factor (char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    if (record.lexeme == "-"){
        SA_output (outfile, "<Factor> -> - <primary>\n");
    }
    else {
        SA_output (outfile, "<Factor> -> <primary>\n");
    }
    primary(p, outfile, fin, record, line_code);
}

//still need to remove left recursion; just add empty as the last production
//r26
void term (char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    if (record.lexeme == "*"){
        SA_output (outfile, "<Term> *");
    }
    else if (record.lexeme == "/"){
        SA_output (outfile, "<Term> /");
    }
    else{
        factor(p, outfile, fin, record, line_code);
    }
    
    /*
    else{
     call lexer
     pass value to factor
     check if -
     if not call primary and compare token types
    }
    */
}

//r25
void expression (char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    if (record.lexeme == "+"){
        SA_output (outfile, "<Expression> -> + <Term> <Expression Prime>");
    }
    else if (record.lexeme == "-"){
        SA_output (outfile, "<Expression> -> - <Term> <Expression Prime>");
    }
    else if (record.lexeme == ";"){
        SA_output (outfile, "<Expression Prime> -> Epsilon");
    }
    else{
        term(p, outfile, fin, record, line_code);
    }
}

//r17
void assign (char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    SA_output(outfile, "<Assign> -> <Identifier> = <Expression>\n");
    record = lexer (p, outfile, fin, line_code);
    while ((is_space(record.lexeme[0])) || (record.lexeme.length() == 0)) {
        cout << "2 space" << endl;
        record = lexer (p, outfile, fin, line_code);
    }
    
    if (record.lexeme[0] == '='){
        record = lexer(p, outfile, fin, line_code);
        while ((is_space(record.lexeme[0])) || (record.lexeme.length() == 0)) {
            record = lexer (p, outfile, fin, line_code);
        }
        if (record.token == "identifier")
            cout << "we out here" << endl;
            expression(p, outfile, fin, record, line_code);
    }
    else {
        cout << "syntax error:  " << record.lexeme << record.token << "hello" << endl;
    }
    
}

//r15
void statement(char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    if (record.token == "identifier"){
        cout << record.token << " is the same as identifier" << endl;
        SA_output(outfile, "<Statement> -> <Assign>\n");
        assign(p, outfile, fin, record, line_code);
    }
    else{
        cout << "statement else" << endl;
        exit(0);
    }
}

//The start of the syntax analyzation
void SA(char *&p, ofstream & outfile, fstream & fin, LA_output & record, string & line_code){
    
    record = lexer (p, outfile, fin, line_code);
    while ((is_space(record.lexeme[0])) || (record.lexeme.length() == 0)){
        record = lexer (p, outfile, fin, line_code);
    }
    
    statement(p, outfile, fin, record, line_code);
    //cout << record.lexeme << "\t" << record.token << endl;
    
}
/////////////////////////////////////////////////////////////////

int main() {
    
    //read file
    fstream fin;
    
    //candidate lexeme
    char * lex_candid;
    
    //holds each input file line
    string line_code;
    string file_name;
    
    //structure containing lexer function results
    LA_output record;
    
    //prompt user to enter file name
    cout << "What is the name of the txt file you want to test:  " << endl;
    cin >> file_name;
    fin.open(file_name);
    
    //while unable to open file prompt user to re-enter file name
    while (!(fin.is_open())){
        cout << "Unable to open file; please re-enter file name" << endl;
        cin >> file_name;
        fin.open(file_name);
    }
    
    //creating and formatting output file
    ofstream outfile("output.txt");
    outfile << setw(10)<<"token"<<"\t\t\t" << "lexeme" <<endl;
    outfile << "--------------------------------------------------------------\n";
    
    //while there are remaining code lines
    while (getline(fin, line_code)) {
        //point to the first character of line
        lex_candid = &line_code[0];
        while (lex_candid != &line_code[line_code.length()]) {
            //calling lexer and storing results
            //record = lexer (lex_candid, outfile, fin, line_code);
            //pass record to the SA
            SA (lex_candid, outfile, fin, record, line_code);
            cout << "after SA" << endl;
            //find rules
            //return if token type matches with rule
            
        }
    }
    
    fin.close();
    outfile.close();
    return 0;
}

