//Arshya Sharifian
//CWID: 889626362
//481_BFS_implementation_DATE_3_19_2018_TIME_1201

#include <iostream>
using namespace std;

//Node for simple tree
struct Node{
    char elem = 32;
    Node * left_child = NULL;
    Node * middle_child = NULL;
    Node * right_child = NULL;
};

int main() {
    //first node
    Node * create_nodes = new Node;
    create_nodes->elem = 'A';
    Node root = *create_nodes;
    
    //third node
    create_nodes = new Node;
    create_nodes->elem = 'B';
    Node b = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'C';
    Node c = *create_nodes;
    
    //second node
    create_nodes = new Node;
    create_nodes->elem = 'D';
    Node d = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'E';
    Node e = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'F';
    Node f = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'G';
    Node g = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'H';
    Node h = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'I';
    Node i = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'J';
    Node j = *create_nodes;
    
    //connecting the nodes
    c.right_child = &h;
    c.left_child = &g;
    
    d.left_child = &i;
    d.right_child = &j;
    
    b.right_child = &f;
    b.left_child = &e;
    
    root.middle_child = &c;
    root.left_child = &b;
    root.right_child = &d;
    
    //serves as iterator
    create_nodes = &root;
    
    //open is an array-based queue
    Node open[3];
    int open_counter = 0;
    
    //first node is root node
    open[open_counter] = root;
    open_counter++;
    
    int bfs_index = 0;
    
    //closed is an array-based queue
    Node closed[3];
    int closed_counter = 0;
    
    //boolean to check if Node X children exist
    bool r_child_exists = false;
    bool l_child_exists = false;
    bool m_child_exists = false;
    
    //SUCCESS value
    char goal = 'k';
    
    while (bfs_index <= open_counter-1){
        //remove node x from open
        if (open[bfs_index].elem == goal){
            cout << "found" << endl;
            exit(0);
        }
       
        //checks if child exists
        if (open[bfs_index].left_child != NULL)
            l_child_exists = true;
        else
            l_child_exists = false;
        
        if (open[bfs_index].middle_child != NULL)
            m_child_exists = true;
        else
            m_child_exists = false;
        
        if (open[bfs_index].right_child != NULL)
            r_child_exists = true;
        else
            r_child_exists = false;
        
        //generate children of x
        Node temp_l_child;
        Node temp_m_child;
        Node temp_r_child;
        
        if ((l_child_exists) && (open[bfs_index].left_child->elem != 32)) temp_l_child = *open[bfs_index].left_child;
        if ((m_child_exists)  && (open[bfs_index].middle_child->elem != 32)) temp_m_child = *open[bfs_index].middle_child;
        if ((r_child_exists)  && (open[bfs_index].right_child->elem != 32)) temp_r_child = *open[bfs_index].right_child;
        
        //put current node in closed queue
        closed[closed_counter] = open[bfs_index];
        closed_counter++;
        
        //discard children of x if in either open or counter
        Node * check_l = &temp_l_child;
        Node * check_m = &temp_m_child;
        Node * check_r = &temp_r_child;
        
        //checks open array
        for (int i = bfs_index; i < open_counter; i++){
            if (check_l == &open[i]){
                l_child_exists = false;
                delete check_l;
            }//end if
            if (check_m == &open[i]){
                m_child_exists = false;
                delete check_m;
            }//end if
            if (check_r == &open[i]){
                r_child_exists = false;
                delete check_r;
            }//end if
        }//end for loop
        
        //check closed array
        for (int i = 0; i < closed_counter; i++){
            if (check_l == &closed[i]){
                l_child_exists = false;
                delete check_l;
            }//end if
            if (check_m == &closed[i]){
                m_child_exists = false;
                delete check_m;
            }//end if
            if (check_r == &closed[i]){
                r_child_exists = false;
                delete check_r;
            }//end if
        }//end for loop
        
        //adding to open queue if child exists
        if (l_child_exists) {
            open[open_counter] = temp_l_child;
            open_counter++;
        }
        if (m_child_exists) {
            open[open_counter] = temp_m_child;
            open_counter++;
        }
        if (r_child_exists){
            open[open_counter] = temp_r_child;
            open_counter++;
        }
        
        bfs_index++;
        cout << "open" << endl;
        for (int i = bfs_index; i < open_counter; i++){
            cout << open[i].elem << endl;
        }
        
        cout << "closed" << endl;
        for (int i = 0; i < closed_counter; i++){
            cout << closed[i].elem << endl;
        }
        
    }//end while
    
    cout << "not found" << endl;

    return 0;
}
