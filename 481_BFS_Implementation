//Arshya Sharifian
//CWID: 889626362
//481_BFS_implementation_DATE_3_19_2018_TIME_1201

#include <iostream>
using namespace std;

//Node for simple tree
struct Node{
    int elem = -1;
    Node * left_child = NULL;
    Node * right_child = NULL;
};

int main() {
    //first node
    Node * create_nodes = new Node;
    create_nodes->elem = 3;
    Node root = *create_nodes;
    
    //second node
    create_nodes = new Node;
    create_nodes->elem = 2;
    Node right = *create_nodes;
    
    //third node
    create_nodes = new Node;
    create_nodes->elem = 1;
    Node left = *create_nodes;
    
    root.left_child = &left;
    root.right_child = & right;
    
    //serves as iterator
    create_nodes = &root;
    
    //open array
    Node open[3];
    int open_counter = 0;
    //first node is root node
    open[open_counter] = root;
    open_counter++;
    
    //closed array
    Node closed[3];
    int closed_counter = 0;
    
    //boolean to check if Node X children exist
    bool r_child_exists = false;
    bool l_child_exists = false;
    
    //SUCCESS value
    int goal = 3;
    
    while (open_counter != 0){
        //remove node x from open
        open_counter--;
        if (open[open_counter].elem == goal){
            cout << "found" << endl;
            exit(0);
        }
       
        //checks if child exists
        if (open[open_counter].right_child != NULL)
            r_child_exists = true;
        else
            r_child_exists = false;
       
        if (open[open_counter].left_child != NULL)
            l_child_exists = true;
        else
            l_child_exists = false;
        
        //generate children of x
        Node temp_r_child;
        Node temp_l_child;
        
        if (r_child_exists) temp_r_child = *open[open_counter].right_child;
        if (l_child_exists) temp_l_child = *open[open_counter].left_child;
        
        //put x on closed
        closed[closed_counter] = open[open_counter];
        closed_counter++;
        
        //discard children of x if in either open or counter
        Node * check_l = &temp_l_child;
        Node * check_r = &temp_r_child;
        
        //checks open array
        for (int i = 0; i < open_counter; i++){
            if (check_l == &open[open_counter]){
                temp_l_child.elem = -1;
            }//end if
            if (check_r == &open[open_counter]){
                temp_r_child.elem = -1;
            }//end if
        }//end for loop
        
        //check closed array
        for (int i = 0; i < closed_counter; i++){
            if (check_l == &closed[closed_counter]){
                delete check_l;
            }//end if
            if (check_r == &closed[closed_counter]){
                delete check_r;
            }//end if
        }//end for loop
        
        //adding to open if child exists
        if (r_child_exists){
            open[open_counter] = temp_r_child;
            open_counter++;
        }
        if (l_child_exists) {
            open[open_counter] = temp_l_child;
            open_counter++;
        }
        
    }//end while
    cout << "not found" << endl;

    return 0;
}
