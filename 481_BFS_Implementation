//Arshya Sharifian
//CWID: 889626362
//481_BFS_implementation_DATE_3_19_2018_TIME_1201

#include <iostream>
using namespace std;

//Node for simple tree
struct Node {
    char elem = 32;
    Node * left_child = NULL;
    Node * middle_child = NULL;
    Node * right_child = NULL;
};

int main() {
    //first node
    Node * create_nodes = new Node;
    create_nodes->elem = 'A';
    Node root = *create_nodes;
    
    //third node
    create_nodes = new Node;
    create_nodes->elem = 'B';
    Node b = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'C';
    Node c = *create_nodes;
    
    //second node
    create_nodes = new Node;
    create_nodes->elem = 'D';
    Node d = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'E';
    Node e = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'F';
    Node f = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'G';
    Node g = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'H';
    Node h = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'I';
    Node i = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'J';
    Node j = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'K';
    Node k = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'L';
    Node l = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'M';
    Node m = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'N';
    Node n = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'O';
    Node o = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'P';
    Node p = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'Q';
    Node q = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'R';
    Node r = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'S';
    Node s = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'T';
    Node t = *create_nodes;
    
    create_nodes = new Node;
    create_nodes->elem = 'U';
    Node u = *create_nodes;
    
   //connecting the nodes
    g.middle_child = &n;
    
    h.left_child = &o;
    h.right_child = &p;
    
    i.left_child = &p;
    i.right_child = &q;
    
    j.middle_child = &r;
    
    k.middle_child = &s;
    
    l.middle_child = &t;
    
    p.middle_child = &u;
    
    c.right_child = &h;
    c.left_child = &g;
    
    d.left_child = &i;
    d.right_child = &j;
    
    b.right_child = &f;
    b.left_child = &e;
    
    e.left_child = &k;
    e.right_child = &l;
    
    f.left_child = &l;
    f.right_child = &m;
    
    root.middle_child = &c;
    root.left_child = &b;
    root.right_child = &d;
    
    //serves as iterator
    create_nodes = &root;
    
    //open is an array-based queue
    Node open[26];
    int open_counter = 0;
    
    //first node is root node
    open[open_counter] = root;
    open_counter++;
    
    int bfs_index = 0;
    
    //closed is an array-based queue
    Node closed[26];
    int closed_counter = 0;
    
    
    //SUCCESS value
    char goal = 'j';
    
    while (bfs_index <= open_counter - 1) {
        
        //boolean to check if Node X children exist
        bool r_child_exists = false;
        bool l_child_exists = false;
        bool m_child_exists = false;
        
        
        //remove node x from open
        if (open[bfs_index].elem == goal) {
            cout << "found" << endl;
            exit(0);
        }
        
        //checks if child exists
        if (open[bfs_index].left_child != NULL)
            l_child_exists = true;
        
        if (open[bfs_index].middle_child != NULL)
            m_child_exists = true;
        
        if (open[bfs_index].right_child != NULL)
            r_child_exists = true;
        
        //generate children of x
        Node temp_l_child;
        Node temp_m_child;
        Node temp_r_child;
        
        if ((l_child_exists) && (open[bfs_index].left_child->elem != 32)) temp_l_child = *open[bfs_index].left_child;
        if ((m_child_exists) && (open[bfs_index].middle_child->elem != 32)) temp_m_child = *open[bfs_index].middle_child;
        if ((r_child_exists) && (open[bfs_index].right_child->elem != 32)) temp_r_child = *open[bfs_index].right_child;
        
        //put current node in closed queue
        closed[closed_counter] = open[bfs_index];
        closed_counter++;
        
        //discard children of x if in either open or counter
        Node * check_l = &temp_l_child;
        Node * check_m = &temp_m_child;
        Node * check_r = &temp_r_child;
        
        //checks open array
        for (int i = bfs_index; i < open_counter; i++) {
            if (check_l->elem == open[i].elem) {
                l_child_exists = false;
                //delete check_l;
            }//end if
            if (check_m->elem == open[i].elem) {
                m_child_exists = false;
                //delete check_m;
            }//end if
            if (check_r->elem == open[i].elem) {
                r_child_exists = false;
                //delete check_r;
            }//end if
        }//end for loop
        
        //check closed array
        for (int i = 0; i < closed_counter; i++) {
            if (check_l == &closed[i]) {
                l_child_exists = false;
                delete check_l;
            }//end if
            if (check_m == &closed[i]) {
                m_child_exists = false;
                delete check_m;
            }//end if
            if (check_r == &closed[i]) {
                r_child_exists = false;
                delete check_r;
            }//end if
        }//end for loop
        
        //adding to open queue if child exists
        if ((l_child_exists)) {
            open[open_counter] = temp_l_child;
            open_counter++;
        }
        if (m_child_exists) {
            open[open_counter] = temp_m_child;
            open_counter++;
        }
        if (r_child_exists) {
            open[open_counter] = temp_r_child;
            open_counter++;
        }
        
        bfs_index++;
        
         cout << "open" << endl;
         for (int i = bfs_index; i < open_counter; i++) {
         cout << open[i].elem << endl;
         }
         
         cout << "closed" << endl;
         for (int i = 0; i < closed_counter; i++) {
         cout << closed[i].elem << endl;
         }
        
        //cout << open_counter << endl;
        
    }//end while
    
    cout << "not found" << endl;
    
    return 0;
}
