#include <iostream>
#include <string>
#include <fstream>
#include<iomanip>

using namespace std;

template <typename T>
void writetofile(ofstream& ofs, T& x, string lexeme) {
    cout << x << "\t\t" << lexeme << endl;
    ofs << setw(10) << x << "\t\t\t" << lexeme << endl;
}
template <typename T>
void writetofile(T* x, string lexeme) { writetofile(*x, lexeme); }


void m_id_key(ofstream& ofs, char *&p, string * keyword) {
    //since starting state is 1 and entering this function requires a letter input
    bool found_keyword = false;
    int state = 2;
    string word = "";
    int id_FSM[6][4]{
        //state   L   D   $
        1,      2,  3,  5,
        2,      4,  3,  5,
        3,      4,  3,  5,
        4,      4,  3,  5,
        5,      6,  6,  6,
        6,      6,  6,  6
    };
    
    //while valid input
    while (((isalpha(*p)) || (isdigit(*p))) || (*p == '$')) {
        if (isalpha(*p)) {
            state = id_FSM[state - 1][1];
        }//end if alpha
        else if (isdigit(*p)) {
            state = id_FSM[state - 1][2];
        }//end else if
        else {
            state = id_FSM[state - 1][3];
        }//end else '$'
        word += *p;
        ++p;
    }//end while
    
    //if accepting state
    if (((state == 2) || (state == 4)) || (state == 5)) {
        //check if keyword
        for (int i = 0; i < 13; i++) {
            if (word == keyword[i]) {
                found_keyword = true;
                writetofile(ofs, word, "keyword");
                
            }//end if keyword
        }//end key for
        if (!found_keyword) {
            writetofile(ofs, word, "identifier");
            
        }
    }//end if accepting state
    //if not accepting state
    else {
        writetofile(ofs, word, "error");
        
    }//end not accepting state
    
}//end function

void m_int_real(ofstream& ofs, char*&p) {
    int state = 2;
    /*
     combination of integer and real number FSM
     states 2 and 3 are accepting states for integer numbers
     state 6 is the accepting state for real numbers
     state 7 is an error state
     */
    int int_real_FSM[8][4]{
        //state     D   .   else
        1,          2,  7,  7,
        2,          3,  7,  7,
        3,          3,  4,  7,
        4,          5,  7,  7,
        5,          6,  7,  7,
        6,          6,  7,  7,
        7,          7,  7,  7
    };
    string word = "";
    //while valid input
    while (isdigit(*p) || (*p) == '.') {
        if (isdigit(*p))
            state = int_real_FSM[state - 1][1];
        else
            state = int_real_FSM[state - 1][2];
        word += *p;
        ++p;
    }//end while valid input
    
    if ((state == 2) || (state == 3)) {
        cout << word << "\t\t\tinteger" << endl;
        writetofile(ofs, word, "integer");
    }
    else if (state == 6) {
        cout << word << "\t\t\treal" << endl;
        writetofile(ofs, word, "real");
    }
    else {
        cout << word << "\t\t\tunknown" << endl;
        writetofile(ofs, word, "unknown");
    }
}//end function

bool is_sep(ofstream& ofs, char *&p, char * sep) {
    string word = "";
    for (int i = 0; i < 10; i++) {
        if ((*p) == sep[i]) {
            if (*p == '%') {
                word += *p;
                ++p;
                if (*p == '%') {
                    word += *p;
                    cout << word << "\t\t\tseparator" << endl;
                    writetofile(ofs, word, " separator");
                    ++p;
                    return true;
                }//end if second char is a %
                //if next character isn't %, then there is an error
                cout << word << "\t\t\terror" << endl;
                writetofile(ofs, word, " error");
                return true;
            }//end if p is a %
            char tmp = p[0];
            cout << *p << "\t\t\tseparator" << endl;
            writetofile(ofs, tmp, "separator");
            ++p;
            return true;
        }//end if separator
    }//end for
    return false;
}//end function


bool is_op(ofstream& ofs, char *&p, char * ope) {
    string word_ope = "";
    for (int i = 0; i < 8; i++) {
        if (*p == ope[i]) {
            word_ope += *p;
            ++p;
            for (int k = 0; k < 8; k++) {
                if (*p == ope[k]) {
                    word_ope += *p;
                    ++p;
                    break;
                }//end if
            }//end for k
            
            writetofile(ofs, word_ope, "operator");
            return true;
        }//end if og is operator
    }//end for i
    return false;
}//end function


int main() {
    
    string keywords[13] = { "int","boolean","real","function","return","true",
        "false","if","else","endif","while","get","put" };
    char separators[10] = { '(',')',':',',','{','}', ']', '[', ';', '%' };
    char operators[8] = { '<','>','=','^','+','-','*','/' };
    fstream fin;
    char * p;
    string x;
    fin.open("TestCase_2.txt");
    ofstream outfile("output.txt");
    
    outfile << setw(10)<<"token"<<"\t\t\t" << "lexeme" <<endl;
    outfile << "--------------------------------------------------------------\n";
    //	outfile.close();
    while (getline(fin, x)) {
        p = &x[0];
        while (p != &x[x.length()]) {
            if (isalpha(*p))m_id_key(outfile, p, keywords);
            else if (isdigit(*p))m_int_real(outfile, p);
            else if (is_op(outfile, p, operators)) {}
            else if (is_sep(outfile, p, separators)) {}
            else if ((((*p) == 32) || (*p == '\t')) || ((*p == '\n') || (int)(*p) == 13)) { ++p; }
            else if (*p == '!')
            {
                ++p;
                while (*p != '!')
                {
                    if (p != &x[x.length()])
                        ++p;
                    else
                    {
                        getline(fin, x);
                        p = &x[0];
                    }
                }
                ++p;
            }
            else {
                cout << *p << "\t\t\tunknown" << endl;
                char tmp = p[0];
                writetofile(outfile, tmp, "error");
                ++p;
            }//end else error
        }//end while  p is within length
    }//end while getline
    fin.close();
    outfile.close();
    return 0;
}
