#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;

class Property{
public:
    long AIN;
    int Prop_code;
    string general_use;
    string specific_use;
    int year_built;
    int effective_year_built;
    int SQFT_home;
    int num_bed;
    int num_bath;
    int recording_date;
    double tot_value;
    int address_number;
    string address_street;
    string address_city;
    int address_zip;
    double center_lat;
    double center_long;
};

int sum_per_square_foot = 0;
int average_square_foot_price;

bool add_feature (int col_num, Property & new_prop, string prop_field){
    
    switch (col_num){
        case 0: new_prop.AIN = stol(prop_field);
            break;
        case 1: new_prop.Prop_code = stoi(prop_field);
            break;
        case 2: new_prop.general_use = (prop_field);
            break;
        case 3: new_prop.specific_use = (prop_field);
            break;
        case 4: new_prop.year_built = stoi(prop_field);
            break;
        case 5: new_prop.effective_year_built = stoi(prop_field);
            break;
        case 6: new_prop.SQFT_home = stoi(prop_field);
                sum_per_square_foot+=new_prop.SQFT_home;
            break;
        case 7: new_prop.num_bed = stoi(prop_field);
            break;
        case 8: new_prop.num_bath = stoi(prop_field);
            break;
        case 9: new_prop.recording_date = stoi(prop_field);
            break;
        case 10: new_prop.tot_value = stod(prop_field);
            break;
        case 11: new_prop.address_number = stoi(prop_field);
            break;
        case 12: new_prop.address_street = (prop_field);
            break;
        case 13: new_prop.address_city = (prop_field);
            break;
        case 14: new_prop.address_zip = stoi(prop_field);
            break;
        case 15: new_prop.center_lat = stod(prop_field);
            break;
        case 16: new_prop.center_long = stod(prop_field);
            break;
        default: cout << "error" << endl;
            return false;
    }
    
    return true;
}

bool print_prop_vector (const vector <Property> & prop_list){
    
    //average square foot for home = total per_square_foot/vector size;
    
    for (int i = 0; i < prop_list.size(); i++){
        int per_square_foot = prop_list[i].tot_value/prop_list[i].SQFT_home;
        sum_per_square_foot +=per_square_foot;
        
        
        if (prop_list[i].year_built != prop_list[i].effective_year_built){
            if (prop_list[i].effective_year_built >=5){
                cout << prop_list[i].AIN << endl;
                cout << prop_list[i].effective_year_built << endl;
            }
        }
        
        //cout << "price per square foot: \t" << per_square_foot << endl;
    }
    
    int average_square_foot_price = sum_per_square_foot/prop_list.size();
    cout << "average square foot price: \t" << average_square_foot_price << endl;
    
    return true;
}

vector <Property> create_property_DB(fstream & fin, string & line){
    
    int column_count = 0;
    string keyword = "";
    vector <Property> prop_list;
    while (getline(fin, line)){
        Property new_prop;
        for (int i = 0; i < line.length(); i++){
            if (line[i] == '"'){
                i++;
                if (column_count == 10){
                    i++;
                }
                while (line[i]!= '"'){
                    if (line[i]!=',')
                        keyword+=line[i];
                    i++;
                }
            }
            if ((line[i] == ',') || i+1 == line.length()){
               
                
                //cout << keyword << endl;
                if (!(add_feature (column_count, new_prop, keyword))) exit(0);
                keyword = "";
                column_count++;
            }
            else{
                if (!((line[i] == '"') || (line[i] == '$')))
                    keyword+=line[i];
            }
        }
        prop_list.push_back(new_prop);
        column_count = 0;
    }//end while
    
    average_square_foot_price = sum_per_square_foot/prop_list.size();
    
    return prop_list;
    
}





void rule1(const Property & cand){
        if (cand.effective_year_built == cand.year_built)
            if (cand.effective_year_built < 2000){
                cout << "this is a good property" << endl;
                cout << cand.AIN << endl;
            }
}

 void rule0 (const Property & cand, const int & average_square_foot_price){
    if (cand.SQFT_home <= average_square_foot_price){
        //proceed to next rule
        rule1(cand);
    }
 }
 
 


/*
 Rule Translations (using data column values):
 (Rule 0): IF price_per_sq_foot < average THEN we will consider the property
 (Rule 1): IF effective year built != year built THEN property is flipped = bad #increment flipped
 //if land value > improvement value
 (Rule 5 and 7): If a property is close to a property that is commercial, fractured, or subdivided = good.
 (Rule 3 and 6):
 IF prop.13 date AND IF prop.13 date did not previously exist =  neutral;
 ELSE IF prop.13 date was <=5 years ago  = slightly bad
 ELSE neutral
 (Rule 8): IF price sold <= average price THEN good
 (Rule 9) IF sqft_main (size of house) >= 5000 THEN really good
 (Rule 10) IF year built >= 2000 AND year built == effective year built, THEN good
 */

/*
 What are some important statistics to track?
 price_per_square_foot
 avg_price_per_square_foot
 
 
 */



int main() {
    
    string line;
    fstream fin;
    fin.open("p1.csv");
    getline(fin, line);
    vector <Property> prop_list;
    
    prop_list = create_property_DB(fin, line);
    
    for (int i = 0; i < prop_list.size(); i++){
        rule0(prop_list[i], average_square_foot_price);
    }
    
    //print_prop_vector(prop_list);

    return 0;
}
